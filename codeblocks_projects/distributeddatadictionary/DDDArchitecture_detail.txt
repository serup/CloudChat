Data Dictionary Architecture setup

DDD - Distributed Data Dictionary
 There are two folders on each node - 'data' and 'dictionary' - inside the dictionary folder lies blockfiles with datadictionary realm file definitions
 and inside data lies database realm files formatted in according to the dictionary definition files

 DDDAdmin+--+-zookeeper(zk)
 +                                 
 |                                   
 +-----+----+-----+------+-------+------+-------+-------+--------------------------------------+
 |   CONNECTIVITY LAYER - CL's (collection of proactor entities connected in a tree like structure)
 |   example:
 |                (CL) 'has two connected CL's'
 |                | |
 |       (CL)+----+ +(CL)
 |         |           |
 |   DDDAdmin(zk)      +-(CL) 'has two connected CL's'
 |     |                 ||
 |     +-(DDNode)        |+-(CL) 'has two connected DDDAdmin'
 |     +-(DDNode)        |   ||
 |     +-(DDNode)        |   |+-------------+
 |     +-(DDNode)        |   |              |
 |     +-(DDNode)        |   DDDAdmin(zk)   DDDAdmin(zk)
 |     +-(DDNode)        |    +-DDNode       |
 |                       |                   +-DDNode
 |                       |                   +-DDNode
 |                       +-(CL)
 |                           |
 |                           DDDAdmin
 |                            |
 |                            +DDNode 'DDNode can be connected to any DDDAdmin' 
 +-----+----+-----+------+-------+------+-------+-------+-------------------------------+-------
 |          |            |              |               |                               |
 [DDNode]   [DDNode]     [DDNode]      [DDNode]    [DDNode]                         [DDNode]     ... 6 node example, it could be many more nodes
 |                                      |                                           |
 +-[BFi]                                +-[BFi]                                     +-[BFi]
     |                                      |                                           |
     +-[BlockEntity]                        +-[BlockEntity]                             +-[BlockEntity]
        |                                       |                                           |
        +-[BlockRecord]                         +-[BlockRecord]                             +-[BlockRecord]
        +-[BlockRecord]                         +-[BlockRecord]                                 |
        |  |                                    |  |                                            +-[chunk record aka toast record]
        |  +-[chunk record aka toast record]    |  +-[chunk record aka toast record]                |   
        |       |                               |  |    |                                           +-[attribut_chunk_data] 
        |       +-[attribut_chunk_data]         |  |    +-[attribut_chunk_data]                         - third chunk of an attribut (fx. attribut 'foto')
        |                                       |  |        - first chunk of an attribut (fx. attribut 'foto')
        |                                       |  |        
        |                                       |  +-[chunk record aka toast record]
        |                                       |     |
        |                                       |     +-[attribut_chunk_data] 
        |                                       |           - second chunk of an attribut (fx. attribut 'foto') 
        +-[BlockRecord]                         +-[BlockRecord]
        |                                       |
        + etc...........................        + etc...........................


Reason for having CONNECTIVITY LAYER is to make sure that DDNodes are loosely coupled, meaning that there is no direct TCPIP port connection from outside
to any DDNode.
It is only possible to communicate with the DDNodes via the DDDAdmin's via CL - sending a datapacket with src and dest toward and from a DDNode->DDDAdmin.
The job of the connectivity layer is to take care of all trafic to and from the DDDAdmin's and it is DDDAdmin responsibility to maintain and control the DDNodes attached to it. The zookeeper service will be updated by the DDDAdmin entity, making sure that data is accessed correctly and with the correct access rights. 
The CONNECTIVITY LAYER is transparent and it is only DDDAdmin which knows about its existence and where to connect to it. 
The DDDAdmin's then have zookeeper in the background and each DDDAdmin of the CONNECTIVITY LAYER will communicate with it to make sure transactions to and from DataDictionary files .BFi is done according to specs.
The DDNode's could be connected to DDDAdmin's using TCPIP or UDP, actually the DDNode is responsible for trying to find a DDDAdmin and update it with its own status and findings - a DDNode could be offline to DDDAdmin for a long time, doing some work, this work could be some request given from DDDAdmin and the result could take a long time to compile and add to DDD (.BFi files), it would then connect to DDDAdmin and tell it about the finished request, then DDDAdmin would take over and create some more request to handle further process of the results

example:(TODO: needs more work, and a MSC showing it in detail)

* DDDAdmin wants to fetch a specific attribut from dataditionary
	
   . DDDAdmin connects to nearby CL, if available, and informs zookeeper that entity is online
     zookeeper sends response to DDDAdmin telling it about its security access level
   . CL handles connectivity between multiple DDDAdmin's 
   . DDDAdmin creates a RFD - Request For Data and creates a zookeeper RFD session object (zkRFDobj)
   . DDDAdmin sends RFD to nearby CL and towards local connected DDNodes
   . CL receives RFD as DED packet and transmit it towards all known sources, or to sources described in the DED protocol
   . ALL DDDAdmin's which have DDNodes connected, will send an event [RFDevent] ( a request for data event ) to DDNodes
   . DDNodes receives RFDevent and initiates a sweep search for data
   . DDNodes which have found the requested data, will send a RFDResponse to nearby DDDAdmin 
   . DDDAdmin receives RFDResponse and updates zookeeper zkRFDobj with info about which DDNode has data
   . DDDAdmin sends an event object about the zkRFDobj in zookeeper to DDDAdmin which send RFD 
   . DDDAdmin receives event about RFD
   . DDDAdmin loops list of DDNodes which have responded to RFD and sends them a FAR (Fetch Attribut Request)
   . DDNodes receive FAR 
   . DDNode fetch .BFi file and send result toward FAR src
   . DDDAdmin receives incomming data blocks
  >. DDDAdmin reads/merges and assemble the attribut requested from the data blocks received from the DDNodes
   . DDDAdmin sends a ERFD (End Request For Data) event update to zkRFDobj to zookeeper, telling it about the success/failure of the RFD
   . DDDAdmin informs zookeeper that entity is offline - removing tempory objects from zookeeper database and disconnect from nearby CL


The Data Dictionary should have the ability to store and access datablocks of enormous sizes - think like this: only the amount of DDNode's .BFi determine the maximum size of a datablock. Its main objective is to create a platform for handling data - all data.
The handling of data will be done in many ways, however with DDD it will be possible to go back to basic, each datablock/attribut in the DDD should be handled using simple filehandlers like simple files, and data should only be transfered when needed, when the filehandle is pointing towards some bytes stored in an attribut in a .BFi file far away from the DDDAdmin reguesting to read from it, then the bytes will be transfered and only then - this is one way of handling data in DDD

Fetching an attribut from DDD could also be done like this; Request from DDDAdmin towards DDNodes asking for an attribute, then DDNodes will find a record containing the attribut and sending it towards DDDAdmin, and DDDAdmin will assemble results from DDNodes and fetch attribut from the assembled result (this is pt. what project can do, however more work towards creating a handle aka filehandler for the requested data/attribut is needed)

