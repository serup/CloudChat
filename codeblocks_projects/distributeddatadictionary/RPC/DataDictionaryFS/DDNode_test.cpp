/*
 * vim:noexpandtab:shiftwidth=4:tabstop=4:
 *
 * Copyright (C) Johnny Serup
 *
 * 
 */
#define BOOST_TEST_MODULE DDNode_test
#define BOOST_TEST_DYN_LINK
#include <boost/test/included/unit_test.hpp>
#include <boost/test/results_reporter.hpp>
#include <boost/algorithm/string.hpp>
#include <boost/property_tree/xml_parser.hpp>
#include <boost/property_tree/ptree.hpp>
#include <boost/foreach.hpp>
#include <boost/thread/condition.hpp>
#include <boost/thread/mutex.hpp>
#include <boost/filesystem.hpp>
#include "zookeeper.hpp"
#define BOOST_FILESYSTEM_NO_DEPRECATED
#include <boost/filesystem.hpp>
#include <boost/thread.hpp>
#include <rpc/pmap_clnt.h>
#include <iostream>
#include <fstream>      // std::ifstream
#include "DDNode.h"
#include "RPCclient.h"
#include "DDDfs.h"
#include "mockRPCServer.h"
#include "dummyrequest.h"
#include "ServerRequestHandling.h"
#include "ClientRequestHandling.h"
#include "../../datadictionarycontrol.hpp"
#include <errno.h>
#include "../../collectablefutures.hpp"


#include <type_traits>
#include <vector>
#include <tuple>
#include <iostream>


#if defined(_M_X64) || defined(__amd64__)
// unfortunately FOLLY is pt[2017-01-01]. only working for 64bit architecture
//#define FOLLY
#endif
#ifdef FOLLY
#include <folly/futures/Future.h> 
#include <folly/futures/Promise.h>
using folly::Future;
using folly::collect;
using folly::makeFuture;
using folly::Promise;
#endif

using namespace std;
using namespace boost::unit_test;
using boost::property_tree::ptree;
using namespace DDDfsRPC;
//using Func = std::function<std::vector<unsigned char>()>;

#if defined(_M_X64) || defined(__amd64__)
#define writer_make_settings boost::property_tree::xml_writer_make_settings<std::string>('\t', 1)
#else
#define writer_make_settings boost::property_tree::xml_writer_make_settings<char>('\t', 1) 
#endif
	
#define BOOST_AUTO_TEST_MAIN
#ifndef NOTESTRESULTFILE
#ifdef BOOST_AUTO_TEST_MAIN
std::ofstream out;

// Based upon autogenerated file DDDfs_svc.cpp <-- generated from DDDfs.x

struct ReportRedirector
{
	ReportRedirector()
	{
		out.open("test_results.xml");
		assert( out.is_open() );
		boost::unit_test::results_reporter::set_stream(out);
	}
};


BOOST_GLOBAL_FIXTURE(ReportRedirector)
#endif
#endif


BOOST_AUTO_TEST_SUITE (DDNode_Test) // name of the test suite

/**
 * RPCclient request to Server
 */
BOOST_AUTO_TEST_CASE(handleRequest_helloworld)
{
	cout<<"BOOST_AUTO_TEST_CASE( handleRequest_helloworld)\n{"<<endl;    

	dddfsServer* pddfsServer = new dddfsServer();
	BOOST_CHECK(pddfsServer!=NULL);

	DDRequest req = createDummyDDRequest();
	DEDBlock* pDEDBlock = pddfsServer->handleRequest(req);
	BOOST_CHECK(pDEDBlock!=NULL);

	/* defined in DDDfs.x --> rpcgen --> DDDfs.h
	struct DEDBlock {
		long transID;
		struct {
			u_int data_len;
			char *data_val;
		} data;
	}; */

	BOOST_CHECK(pDEDBlock->transID>0);
	BOOST_CHECK(pDEDBlock->data.data_len>0);
	BOOST_CHECK(pDEDBlock->data.data_val!=NULL);

	DED_PUT_DATA_IN_DECODER(decoder_ptr,(unsigned char*)pDEDBlock->data.data_val,pDEDBlock->data.data_len);
	BOOST_CHECK(decoder_ptr != 0);

	bool bDecoded=false;
	std::string strValue;

	// decode data ...
	if( DED_GET_STRUCT_START( decoder_ptr, "DDNodeResponse" ) == true )
	{
		if(	DED_GET_STDSTRING	( decoder_ptr, "message", strValue ) == true )
		{
			if( DED_GET_STRUCT_END( decoder_ptr, "DDNodeResponse" ) == true )
			{
				if(strValue == "Hello World") {
					printf("\nResponse: OK\n"); 
					printf("Response: Datasize: %d\n",pDEDBlock->data.data_len); 
					bDecoded=true;
				}
				else {
					printf("Response: FAIL\n");                                 
				}
			}
			else
			{
				bDecoded=false;
				printf("\nResponse: FAIL\n");                                                                             
			}	
			cout << "message : " << strValue << endl;
		}
	}
	else
		cout << "FAIL: did NOT decode DDNodeResponse" << endl;

	BOOST_CHECK(bDecoded == true);

	cout<<"}"<<endl;   
}

BOOST_AUTO_TEST_CASE(serverclient_udp)
{
	cout<<"BOOST_AUTO_TEST_CASE( serverclient_udp)\n{"<<endl;    
	
	// setup server
	mockRPCServer *pserver = new mockRPCServer();
    pserver->start();
    pserver->wait();				
		
	// setup client
	string str = "localhost" ;
    char const* ca = str.c_str();
	CLIENT *clnt;
	DEDBlock  *result_1;
	
	DDRequest req = createDummyDDRequest();

	cout << "create udp clnt" << endl;
	clnt = clnt_create (ca, DDD_FS_PROG, DDD_FS_VERS, "udp");
	BOOST_CHECK(clnt != NULL);

	if(clnt != NULL) {	
		cout << "call via udp function in server" << endl;	
		result_1 = dddfs_1(req, clnt);
		if (result_1 != (DEDBlock *) NULL) {
			    cout << endl;
				cout << "received response from server via udp " << endl;
				DED_PUT_DATA_IN_DECODER(decoder_ptr,(unsigned char*)result_1->data.data_val,result_1->data.data_len);
				bool bDecoded=false;
				std::string strValue;

				// decode data ...
				if( DED_GET_STRUCT_START( decoder_ptr, "DDNodeResponse" ) == true )
				{
						if(	DED_GET_STDSTRING	( decoder_ptr, "message", strValue ) == true )
						{
								if( DED_GET_STRUCT_END( decoder_ptr, "DDNodeResponse" ) == true )
								{
										if(strValue == "Hello World") {
												printf("\nResponse: OK\n"); 
												printf("Response: Datasize: %d\n",result_1->data.data_len); 
												bDecoded=true;
										}
										else {
												printf("\nResponse: FAIL\n");                                 
										}
								}
								else
								{
										bDecoded=false;
										printf("\nResponse: FAIL\n");                                                                             
								}	
								cout << "message : " << strValue << endl;
						}
				}
				else
						cout << "FAIL: did NOT decode DDNodeResponse" << endl;

				BOOST_CHECK(bDecoded == true);
		}
		BOOST_CHECK(result_1 != NULL);

		cout << "destroy clnt" << endl;
		clnt_destroy (clnt);
	}

	delete pserver;
	boost::this_thread::sleep( boost::posix_time::milliseconds(10) ); // above functions should not take longer to complete - this is to avoid cluttering up output
	cout<<"}"<<endl;   
}


BOOST_AUTO_TEST_CASE(serverclient_tcp)
{
	cout<<"BOOST_AUTO_TEST_CASE( serverclient_tcp)\n{"<<endl;    
	
	// setup server
	mockRPCServer *pserver = new mockRPCServer();
    pserver->start();
    pserver->wait();				
		
	// setup client
	string str = "localhost" ;
    char const* ca = str.c_str();
	CLIENT *clnt;
	DEDBlock  *result_1;

	DDRequest req = createDummyDDRequest();

	cout << "create tcp clnt" << endl;
	clnt = clnt_create (ca, DDD_FS_PROG, DDD_FS_VERS, "tcp");
	BOOST_CHECK(clnt != NULL);

	if(clnt != NULL) {
		cout << "call via tcp function in server" << endl;	
		result_1 = dddfs_1(req, clnt);
		if (result_1 != (DEDBlock *) NULL) {
			    cout << endl;
				cout << "received response from server via tcp " << endl;
				DED_PUT_DATA_IN_DECODER(decoder_ptr,(unsigned char*)result_1->data.data_val,result_1->data.data_len);
				bool bDecoded=false;
				std::string strValue;

				// decode data ...
				if( DED_GET_STRUCT_START( decoder_ptr, "DDNodeResponse" ) == true )
				{
						if(	DED_GET_STDSTRING	( decoder_ptr, "message", strValue ) == true )
						{
								if( DED_GET_STRUCT_END( decoder_ptr, "DDNodeResponse" ) == true )
								{
										if(strValue == "Hello World") {
												printf("\nResponse: OK\n"); 
												printf("Response: Datasize: %d\n",result_1->data.data_len); 
												bDecoded=true;
										}
										else {
												printf("\nResponse: FAIL\n");                                 
										}
								}
								else
								{
										bDecoded=false;
										printf("\nResponse: FAIL\n");                                                                             
								}	
								cout << "message : " << strValue << endl;
						}
				}
				else
						cout << "FAIL: did NOT decode DDNodeResponse" << endl;

				BOOST_CHECK(bDecoded == true);
		}
		BOOST_CHECK(result_1 != NULL);

		cout << "destroy clnt" << endl;
		clnt_destroy (clnt);
	}

	delete pserver;
	cout<<"}"<<endl;   
}

void dummycallbackfnct(std::unique_ptr<CDataEncoder> &decoder_ptr)
{
	cout << "WARNING: dummycallback was called " << endl;
}

BOOST_AUTO_TEST_CASE(classRPCclient)
{
	cout<<"BOOST_AUTO_TEST_CASE( classRPCclient)\n{"<<endl;    
	
	// setup client
	//
	//
	RPCclient client;

	// setup a request
	DED_START_ENCODER(dedptr);
	DED_PUT_STRUCT_START( dedptr, "DDNodeRequest" );
		DED_PUT_STDSTRING	( dedptr, "Request", (std::string)"hello request" );
	DED_PUT_STRUCT_END( dedptr, "DDNodeRequest" );

	cout << "subtest 1; using internal callback " << endl;
	cout<<"/*{{{*/"<<endl;   
	// test with internal callback function - calls RPCclient::handleResponse
	{
	// setup mock server
	mockRPCServer server;
    server.start();
    server.wait();				
		
	BOOST_CHECK( client.sendRequestTo("localhost", dedptr,123,PINGPONG) == true );
    }
	cout<<"/*}}}*/"<<endl;   

	cout << "subtest 2; using internal callback, when provided callback is zero" << endl;
	cout<<"/*{{{*/"<<endl;   
	// test with internal callback function - calls RPCclient::handleResponse
	{
	// setup mock server
	mockRPCServer server;
    server.start();
    server.wait();				
		
	BOOST_CHECK( client.sendRequestTo("localhost", dedptr,123,PINGPONG,NULL) == true );

    }
	cout<<"/*}}}*/"<<endl;   


	cout << "subtest 3; using dummy callback function " << endl;
	cout<<"/*{{{*/"<<endl;   
	{
	// setup mock server
	mockRPCServer server;
    server.start();
    server.wait();				
		
	BOOST_CHECK( client.sendRequestTo("localhost", dedptr,123,PINGPONG,
					&dummycallbackfnct
  		     	) == true );

    }
	cout<<"/*}}}*/"<<endl;   

	cout << "subtest 4; using a lambda function as callback function " << endl;
	cout<<"/*{{{*/"<<endl;   
	// test with lambda function as callback
	{
	// setup mock server
	mockRPCServer server;
    server.start();
    server.wait();				
	
	// test with lambda function
	BOOST_CHECK( client.sendRequestTo("localhost", dedptr,321,PINGPONG,
			[&](std::unique_ptr<CDataEncoder> &decoder_ptr) // lambda functionality
				{
					printf("************************************************\n");
					printf("WARNING: lambda callback function called \n");
					if (decoder_ptr == 0) { printf(">>> no data received\n"); }
					printf("************************************************\n");
				}
  		     	) == true );

	}
	boost::this_thread::sleep( boost::posix_time::milliseconds(10) ); // above functions should not take longer to complete - this is to avoid cluttering up output
	cout<<"/*}}}*/"<<endl;   

	cout<<"}"<<endl;   
}

BOOST_AUTO_TEST_CASE(RequestResponseMethod)
{
	cout<<"BOOST_AUTO_TEST_CASE( RequestResponseMethod)\n{"<<endl;    
	{
	// setup a request
	DED_START_ENCODER(dedptr);
	DED_PUT_STRUCT_START( dedptr, "DDNodeRequest" );
		DED_PUT_METHOD	( dedptr, "name", (std::string)"myNewRequest" );
	DED_PUT_STRUCT_END( dedptr, "DDNodeRequest" );

	// setup mock server
	mockRPCServer server;
    server.start();
    server.wait();				
		
	// setup client
	RPCclient client;

	// send request to mock server
	BOOST_CHECK( client.sendRequestTo("localhost", dedptr,123,SEARCH) == true );
	} 
	boost::this_thread::sleep( boost::posix_time::milliseconds(10) ); // above functions should not take longer to complete - this is to avoid cluttering up output
	cout<<"}"<<endl;   
}

BOOST_AUTO_TEST_CASE(ClientRequestHandling_connect)
{
	cout << "BOOST_AUTO_TEST_CASE( ClientRequestHandling_connect )\n{" << endl;

	CHandlingRPCclientRequestToServer hcr;
	CHandlingRPCclientRequestToServer::clientInfo *pclientInfo = hcr.createClientInfoObject();

	// connect with empty clientInfo
	BOOST_CHECK(hcr.connect(NULL) == false);
	BOOST_CHECK(hcr.connect(pclientInfo) == false);

	// connect with clientInfo, only transID set
	pclientInfo->transID = 1;
	BOOST_CHECK(hcr.connect(pclientInfo) == true);

	//TODO: add new tests for handling this connect feature

	cout << "}" << endl;
}

BOOST_AUTO_TEST_CASE(RPCclient_connect_to_Server)
{
	cout << "BOOST_AUTO_TEST_CASE( RPCclient_connect_to_Server)\n{" << endl;

	cout<<"/*{{{*/"<<endl;   
	// test with lambda function as callback
	{
	// setup mock server
	mockRPCServer server;
    server.start();
    server.wait();				

	// setup RPCclient
	RPCclient client;

	// setup a RPCclient connect request
	DED_START_ENCODER(dedptr);
	DED_PUT_STRUCT_START( dedptr, "DDNodeRequest" );
		DED_PUT_METHOD	( dedptr, "name", (std::string)"RPCclientConnect" );
	DED_PUT_STRUCT_END( dedptr, "DDNodeRequest" );

	// setup connection from RPCclient to server
	// test with lambda callback function
/*	BOOST_CHECK( client.sendRequestTo("localhost", dedptr,421,CONNECT,
			[&](std::unique_ptr<CDataEncoder> &decoder_ptr) // lambda functionality
				{
					printf("************************************************\n");
					printf("WARNING: lambda callback function called \n");
					if (decoder_ptr == 0) { printf(">>> no data received\n"); }
					printf("************************************************\n");
				}
  		     	) == true );
*/
	BOOST_CHECK( client.sendRequestTo("localhost", dedptr,421,CONNECT) == true );

	}
	boost::this_thread::sleep( boost::posix_time::milliseconds(1000) ); // above functions should not take longer to complete - this is to avoid cluttering up output
	cout<<"/*}}}*/"<<endl;   

	cout << "}" << endl;
}

/**
 * Incomming request from server 
 */
BOOST_AUTO_TEST_CASE(CHandlingServerRequestToClients_init)
{
	cout << "BOOST_AUTO_TEST_CASE( CHandlingServerRequestToClients_init )\n{" << endl;
	{
	CHandlingServerRequestToClients SRC;	

	// setup a request - simulating a request from server
	BOOST_TEST_MESSAGE( "setup a request - simulating a request from server" );
	DDRequest req = createDummyDDRequest();
	DED_PUT_DATA_IN_DECODER(decoder_ptr,(unsigned char*)req.ded.data.data_val, req.ded.data.data_len);

	// test handleRequest function
	BOOST_TEST_MESSAGE( "Verify handleRequest function " );
	BOOST_CHECK(SRC.handlingRequest(decoder_ptr) == false);
	}
	cout << "}" << endl;
}


/*
BOOST_AUTO_TEST_CASE(fetchAttributFrom3BFi_diff_order)
{
	cout<<"BOOST_AUTO_TEST_CASE( fetchAttributFrom3BFi_diff_order)\n{"<<endl;

	using boost::optional;
	using boost::property_tree::ptree;

	CDataDictionaryControl *pDDC = new CDataDictionaryControl();
	std::list<std::string> listResult = pDDC->ls();	
	BOOST_FOREACH(std::string attribut, listResult)
	{
		cout << "- OK attribut : " << attribut << endl;
	}
	BOOST_CHECK(listResult.size() <= 0);

	BOOST_WARN_MESSAGE(listResult.size() <= 0, "Failure since - no .BFi file should be present - PLEASE clean up test area - previous test must have failed, leaving some .BFi files ");

	if(listResult.size() > 0) {
		cout<<"}"<<endl;
		return;
	}

	CDataDictionaryControl *ptestDataDictionaryControl = new CDataDictionaryControl();
	ptree ptListOfBlockRecords;

	// attribut 3
	std::string attributName = "name";
	std::string name = "Johnny Serup";	
	std::vector<unsigned char> attributValue(name.begin(), name.end());

	// attribut 2
	std::string attributName2 = "mobil";
	std::string mobil = "555 - 332 211 900";	
	std::vector<unsigned char> attributValue2(mobil.begin(), mobil.end());

	// attribut 1 - large
	std::string FotoAttributName= "foto"; // it should be ddid -- datadictionary id which refers to attribut description
	std::vector<unsigned char> FotoAttributValue;
	std::string fn = "testImage.png"; // should be of size 10.5 Kb
	std::ifstream is (fn, ios::binary);
	if (is)
	{
		long length = boost::filesystem::file_size(fn);
		std::cout << "[readFile] Reading file: " << fn << " ; amount " << length << " characters... \n";
		// Make sure receipient has room
		FotoAttributValue.resize(length,0);
		//read content of infile
		is.read ((char*)&FotoAttributValue[0],length);
		std::cout << "[readFile] size: " << (int) FotoAttributValue.size() << '\n';
		std::cout << "[readFile] capacity: " << (int) FotoAttributValue.capacity() << '\n';
		std::cout << "[readFile] max_size: " << (int) FotoAttributValue.max_size() << '\n';
		is.close();
	}
	BOOST_CHECK(FotoAttributValue.size() > 0);

	std::string realmName = "profile";
	long maxBlockRecordSize=5456; // should result in multiple BlockRecords inside a BlockEntity	


	cout << "BlockRecord size before: " << maxBlockRecordSize << endl;
	std::string transGuid = "F7C23762ED2823A27E62A64B95C024FF";
	BOOST_CHECK(ptestDataDictionaryControl->addAttributToBlockRecord(transGuid,ptListOfBlockRecords, maxBlockRecordSize, realmName, FotoAttributName, FotoAttributValue)); 
	cout << "BlockRecord size after 1 attribut add : " << maxBlockRecordSize << endl;
	BOOST_CHECK(ptestDataDictionaryControl->addAttributToBlockRecord(transGuid,ptListOfBlockRecords, maxBlockRecordSize, realmName, attributName2, attributValue2)); 
	cout << "BlockRecord size after 2 atrribut add : " << maxBlockRecordSize << endl;
	BOOST_CHECK(ptestDataDictionaryControl->addAttributToBlockRecord(transGuid,ptListOfBlockRecords, maxBlockRecordSize, realmName, attributName, attributValue)); 
	cout << "BlockRecord size after 3 atrribut add : " << maxBlockRecordSize << endl;
	 
	long maxBlockEntitySize=10000; // should result in 3 BlockEntity 	
	boost::property_tree::ptree ptBlockEntity = ptestDataDictionaryControl->addBlockRecordToBlockEntity(transGuid, ptListOfBlockRecords, maxBlockEntitySize);
	BOOST_CHECK(ptBlockEntity.size()>0);

	cout << "XML output of ALL attributs - the foto attribut will be spanning over 3 .BFi files, however here is shown all attributs together: " << endl;
	cout << "*{{{" << endl;
	write_xml(std::cout, ptBlockEntity, writer_make_settings );
	cout << "*}}}" << endl;

	// create BFi files
	std::vector< pair<std::string ,int> > listOfBlockEntityFiles = ptestDataDictionaryControl->writeBlockEntityToBFiFile(ptBlockEntity);
	cout << "Created : " << listOfBlockEntityFiles.size() << " .BFi files " << endl;
	BOOST_CHECK(listOfBlockEntityFiles.size()==3);

	pair <std::string,int> block;
	std::list<std::string> listBFiFiles;
	BOOST_FOREACH(block, listOfBlockEntityFiles)
	{
		cout << "- OK Created file : " << block.first << " size : " << block.second << endl;
		listBFiFiles.push_back(block.first);
	}


	// check that list now contain basic 'listOfBlockRecords' - which is necessary	
	optional< ptree& > child = ptListOfBlockRecords.get_child_optional( "listOfBlockRecords" );
	BOOST_CHECK(child);

	// verify that BlockRecord has been added
	child = ptListOfBlockRecords.get_child_optional( "BlockRecord.chunk_data" );
	BOOST_CHECK(child);

	child = ptListOfBlockRecords.get_child_optional( "BlockRecord.chunk_data.chunk_record" );
	BOOST_CHECK(child);

	child = ptListOfBlockRecords.get_child_optional( "BlockRecord.chunk_data.chunk_record.chunk_ddid" );
	BOOST_CHECK(child);

	cout << "________________________________________" << endl;
	cout << "attributs added : " << endl;
		
	int amountOfBlockRecords = 0;
	int amountOfchunk_records = 0;
	std::string hexdata_attribut1="";
	std::string hexdata_attribut2="";


	BOOST_FOREACH(ptree::value_type &vt, ptListOfBlockRecords.get_child("listOfBlockRecords"))
	{
		cout << " - record id : " << vt.second.get_child("chunk_id").data() << endl;
		if(vt.first == "BlockRecord")
		{
			amountOfBlockRecords++;
			BOOST_FOREACH(ptree::value_type &vt2 , vt.second)
			{
				if(vt2.first == "chunk_data")
				{
					cout << " - " << vt2.first << " : "; 
					std::string attributName="";
					std::string prevattributName="";
					BOOST_FOREACH(ptree::value_type &vt3, vt2.second)
					{
						if(vt3.first == "chunk_record") {
							attributName = vt3.second.get_child("chunk_ddid").data();
							if(prevattributName!=attributName) {
								cout << endl;
								cout << " -- chunk_record : " << vt3.second.get_child("chunk_ddid").data() << " "; 
								prevattributName=attributName;
							}
							else
								cout << ".";
							amountOfchunk_records++;
							if(amountOfchunk_records==1) {
								hexdata_attribut1 = vt3.second.get_child("Data").data();
							}
							if(amountOfchunk_records==2) {
								hexdata_attribut2 = vt3.second.get_child("Data").data();
							}
						}
					}
				}
			}
		}
		cout << endl;
	}

	cout << "________________________________________" << endl;
	if(amountOfBlockRecords==3)
		   	cout << "- OK amount of BlockRecords created: " << amountOfBlockRecords << endl;
	else
		   	cout << "- FAIL: amount of BlockRecords created: " << amountOfBlockRecords << endl;
	BOOST_CHECK(amountOfBlockRecords == 3); // Only one BlockRecord - the attributs should be added to BlockRecord until it is full, then new BlockRecord will be added
	if(amountOfchunk_records == 37)
		cout << "- OK amount of chunk records : " << amountOfchunk_records << endl;
	else
		cout << "- FAIL: amount of chunk records : " << amountOfchunk_records << endl;
	BOOST_CHECK(amountOfchunk_records == 37); // 35 for foto, 1 for mobil, and 1 for name
	cout << "________________________________________" << endl;

	cout << "call ls() - list attributs - validate expected results " << endl;
	listResult = pDDC->ls();	
	//expected : reads like this: <GUID> has a profile folder with attribut name, mobil and foto
	std::string expected1 =  transGuid + "./profile/foto";
	std::string expected2 =  transGuid + "./profile/mobil";
	std::string expected3 =  transGuid + "./profile/name";

	BOOST_CHECK(listResult.size() > 0);

	int c=0;
	BOOST_FOREACH(std::string attribut, listResult)
	{
		c++;
		cout << "- OK attribut : " << attribut << endl;
		if(c==1) BOOST_CHECK(expected1 == attribut);
		if(c==2) BOOST_CHECK(expected2 == attribut);
		if(c==3) BOOST_CHECK(expected3 == attribut);
	}

	cout << "TODO: ls should show attribut spanning over multiple .BFi files in a different way " << endl;

	cout << "________________________________________" << endl;

	cout << "Fetch attribut from .BFi file " << endl;

	cout << "INFO: ftgt should beable to assemble across multiple .BFi files " << endl;
	std::string attributToFetch = transGuid + "./profile/foto";
	pair<std::string, std::vector<unsigned char>> pairAttribut = ptestDataDictionaryControl->ftgt(attributToFetch);
	cout << "Attribut name : " << pairAttribut.first << endl;

	cout << "Original data : " << endl;
	CUtils::showDataBlock(true,true,FotoAttributValue);

	cout << "Result data : " << endl;
	bool bFoundError = CUtils::showDataBlockDiff(true,true,pairAttribut.second, FotoAttributValue);
	if(!bFoundError) cout << "INFO: bytes assembled are equal to original " << endl;
	BOOST_CHECK(bFoundError == false);

	cout << "size of Original : " << FotoAttributValue.size() << " size of result : " << pairAttribut.second.size() << endl;
	int missingbytes = (FotoAttributValue.size() - pairAttribut.second.size());

	if(missingbytes > 0) cout << "FAIL: Missing byte(s) : " << missingbytes << endl;
	BOOST_CHECK(FotoAttributValue.size() == pairAttribut.second.size());

	BOOST_CHECK(FotoAttributValue == pairAttribut.second); // verify that retrieved value is same as stored

	cout << "________________________________________" << endl;

	// Clean up section - must be in bottom
	BOOST_FOREACH(std::string filename, listBFiFiles)
	{
		cout << "- OK Cleanup file : " << filename << endl;
		boost::filesystem::path p = boost::filesystem::path(filename);
		boost::filesystem::remove(filename);
	}
	delete ptestDataDictionaryControl;

	cout<<"}"<<endl;
}


BOOST_AUTO_TEST_CASE(fetchAttributFrom_3_virtual_RPCclients_BFi_Files)
{
	cout<<"BOOST_AUTO_TEST_CASE( fetchAttributFrom_3_virtual_RPCclients_BFi_Files)\n{"<<endl;

	using boost::optional;
	using boost::property_tree::ptree;

	CDataDictionaryControl *pDDC = new CDataDictionaryControl();
	std::list<std::string> listResult = pDDC->ls();	
	BOOST_FOREACH(std::string attribut, listResult) { cout << "- OK attribut : " << attribut << endl; }
	BOOST_CHECK(listResult.size() <= 0);
	BOOST_WARN_MESSAGE(listResult.size() <= 0, "Failure since - no .BFi file should be present ");

	if(listResult.size() <= 0) {

		CDataDictionaryControl *ptestDataDictionaryControl = new CDataDictionaryControl();
		ptree ptListOfBlockRecords;

		// attribut 3
		std::string attributName = "name";
		std::string name = "Johnny Serup";	
		std::vector<unsigned char> attributValue(name.begin(), name.end());

		// attribut 2
		std::string attributName2 = "mobil";
		std::string mobil = "555 - 332 211 900";	
		std::vector<unsigned char> attributValue2(mobil.begin(), mobil.end());

		// attribut 1 - large
		std::string FotoAttributName= "foto"; // it should be ddid -- datadictionary id which refers to attribut description
		std::vector<unsigned char> FotoAttributValue;
		std::string fn = "testImage.png"; // should be of size 10.5 Kb
		std::ifstream is (fn, ios::binary);
		if (is)
		{
			long length = boost::filesystem::file_size(fn);
			std::cout << "[readFile] Reading file: " << fn << " ; amount " << length << " characters... \n";
			// Make sure receipient has room
			FotoAttributValue.resize(length,0);
			//read content of infile
			is.read ((char*)&FotoAttributValue[0],length);
			//std::cout << "[readFile] size: " << (int) FotoAttributValue.size() << '\n';
			//std::cout << "[readFile] capacity: " << (int) FotoAttributValue.capacity() << '\n';
			//std::cout << "[readFile] max_size: " << (int) FotoAttributValue.max_size() << '\n';
			is.close();
		}
		BOOST_CHECK(FotoAttributValue.size() > 0);

		std::string realmName = "profile";
		long maxBlockRecordSize=5456; // should result in multiple BlockRecords inside a BlockEntity	


		cout << "BlockRecord size before: " << maxBlockRecordSize << endl;
		std::string transGuid = "F9C23762ED2823A27E62A64B95C024FF";
		BOOST_CHECK(ptestDataDictionaryControl->addAttributToBlockRecord(transGuid,ptListOfBlockRecords, maxBlockRecordSize, realmName, FotoAttributName, FotoAttributValue)); 
		cout << "BlockRecord size after 1 attribut add : " << maxBlockRecordSize << endl;
		BOOST_CHECK(ptestDataDictionaryControl->addAttributToBlockRecord(transGuid,ptListOfBlockRecords, maxBlockRecordSize, realmName, attributName2, attributValue2)); 
		cout << "BlockRecord size after 2 atrribut add : " << maxBlockRecordSize << endl;
		BOOST_CHECK(ptestDataDictionaryControl->addAttributToBlockRecord(transGuid,ptListOfBlockRecords, maxBlockRecordSize, realmName, attributName, attributValue)); 
		cout << "BlockRecord size after 3 atrribut add : " << maxBlockRecordSize << endl;

		long maxBlockEntitySize=10000; // should result in 3 BlockEntity 	
		boost::property_tree::ptree ptBlockEntity = ptestDataDictionaryControl->addBlockRecordToBlockEntity(transGuid, ptListOfBlockRecords, maxBlockEntitySize);
		BOOST_CHECK(ptBlockEntity.size()>0);

		//cout << "XML output of ALL attributs - the foto attribut will be spanning over 3 .BFi files, however here is shown all attributs together: " << endl;
		//cout << "*{{{" << endl;
		//write_xml(std::cout, ptBlockEntity, boost::property_tree::xml_writer_make_settings<std::string>('\t', 1) );
		//cout << "*}}}" << endl;

		// create BFi files
		std::vector< pair<std::string ,int> > listOfBlockEntityFiles = ptestDataDictionaryControl->writeBlockEntityToBFiFile(ptBlockEntity);
		cout << "Created : " << listOfBlockEntityFiles.size() << " .BFi files " << endl;
		BOOST_CHECK(listOfBlockEntityFiles.size()==3);

		pair <std::string,int> block;
		std::list<std::string> listBFiFiles;
		BOOST_FOREACH(block, listOfBlockEntityFiles)
		{
			cout << "- OK Created file : " << block.first << " size : " << block.second << endl;
			listBFiFiles.push_back(block.first);
		}


		// check that list now contain basic 'listOfBlockRecords' - which is necessary	
		optional< ptree& > child = ptListOfBlockRecords.get_child_optional( "listOfBlockRecords" );
		BOOST_CHECK(child);

		// verify that BlockRecord has been added
		child = ptListOfBlockRecords.get_child_optional( "BlockRecord.chunk_data" );
		BOOST_CHECK(child);

		child = ptListOfBlockRecords.get_child_optional( "BlockRecord.chunk_data.chunk_record" );
		BOOST_CHECK(child);

		child = ptListOfBlockRecords.get_child_optional( "BlockRecord.chunk_data.chunk_record.chunk_ddid" );
		BOOST_CHECK(child);

		cout << "________________________________________" << endl;
		cout << "attributs added : " << endl;

		int amountOfBlockRecords = 0;
		int amountOfchunk_records = 0;
		std::string hexdata_attribut1="";
		std::string hexdata_attribut2="";


		BOOST_FOREACH(ptree::value_type &vt, ptListOfBlockRecords.get_child("listOfBlockRecords"))
		{
			cout << " - record id : " << vt.second.get_child("chunk_id").data() << endl;
			if(vt.first == "BlockRecord")
			{
				amountOfBlockRecords++;
				BOOST_FOREACH(ptree::value_type &vt2 , vt.second)
				{
					if(vt2.first == "chunk_data")
					{
						cout << " - " << vt2.first << " : "; 
						std::string attributName="";
						std::string prevattributName="";
						BOOST_FOREACH(ptree::value_type &vt3, vt2.second)
						{
							if(vt3.first == "chunk_record") {
								attributName = vt3.second.get_child("chunk_ddid").data();
								if(prevattributName!=attributName) {
									cout << endl;
									cout << " -- chunk_record : " << vt3.second.get_child("chunk_ddid").data() << " "; 
									prevattributName=attributName;
								}
								else
									cout << ".";
								amountOfchunk_records++;
								if(amountOfchunk_records==1) {
									hexdata_attribut1 = vt3.second.get_child("Data").data();
								}
								if(amountOfchunk_records==2) {
									hexdata_attribut2 = vt3.second.get_child("Data").data();
								}
							}
						}
					}
				}
			}
			cout << endl;
		}

		cout << "________________________________________" << endl;
		if(amountOfBlockRecords==3)
			cout << "- OK amount of BlockRecords created: " << amountOfBlockRecords << endl;
		else
			cout << "- FAIL: amount of BlockRecords created: " << amountOfBlockRecords << endl;
		BOOST_CHECK(amountOfBlockRecords == 3); // Only one BlockRecord - the attributs should be added to BlockRecord until it is full, then new BlockRecord will be added
		if(amountOfchunk_records == 37)
			cout << "- OK amount of chunk records : " << amountOfchunk_records << endl;
		else
			cout << "- FAIL: amount of chunk records : " << amountOfchunk_records << endl;
		BOOST_CHECK(amountOfchunk_records == 37); // 35 for foto, 1 for mobil, and 1 for name
		cout << "________________________________________" << endl;

		cout << "call ls() - list attributs - validate expected results " << endl;
		listResult = pDDC->ls();	
		//expected : reads like this: <GUID> has a profile folder with attribut name, mobil and foto
		std::string expected1 =  transGuid + "./profile/foto";
		std::string expected2 =  transGuid + "./profile/mobil";
		std::string expected3 =  transGuid + "./profile/name";

		BOOST_CHECK(listResult.size() > 0);

		int c=0;
		BOOST_FOREACH(std::string attribut, listResult)
		{
			c++;
			cout << "- OK attribut : " << attribut << endl;
			if(c==1) BOOST_CHECK(expected1 == attribut);
			if(c==2) BOOST_CHECK(expected2 == attribut);
			if(c==3) BOOST_CHECK(expected3 == attribut);
		}

		cout << "TODO: ls should show attribut spanning over multiple .BFi files in a different way " << endl;

		cout << "________________________________________" << endl;

		cout << "*** SIMULATE that parsing result of .BFi files comes from 3 different RPCclients" << endl;
		cout << "*{{{" << endl;
		std::string attributToFetch = transGuid + "./profile/foto";
		
		std::vector<std::list< pair<seqSpan, std::vector<assembledElements>>>> resultFromRPCclients (3); // testcase has only 3 virtual RPCclients delivering results
	
		boost::filesystem::path currentSearchDirectory( boost::filesystem::current_path() );
		boost::filesystem::recursive_directory_iterator directoryIterator(currentSearchDirectory), eod;

		int n=0;
		BOOST_FOREACH(boost::filesystem::path const& currentfile, make_pair(directoryIterator, eod))
		{
			std::list<pair<seqSpan, std::vector<assembledElements>>> AttributInblockSequenceFromBFifile;


			if((boost::filesystem::extension(currentfile.string()) == BFI_FILE_EXTENSION)) { 
				cout << "virtual RPCclient " << n+1 << " : " << endl;
				cout << "*{{{" << endl;
				cout << "  Fetch attribut from .BFi file " << endl;
				ptestDataDictionaryControl->fetchAttributsFromFile(currentfile, AttributInblockSequenceFromBFifile); 

				cout << "  prepare result in a BLOB " << endl;
				transferBLOB stBlob = ptestDataDictionaryControl->convertToBLOB(AttributInblockSequenceFromBFifile,true);
				BOOST_CHECK(stBlob.eType == transferBLOB::enumType::ATTRIBUTS_LIST);
				
				cout << "  simulate transfer / receive from RPCclient to server " << endl;
				cout << "  convert result in BLOB to list pair<seq,vector<assembledElements>> " << endl;
				
				std::list<pair<seqSpan, std::vector<assembledElements>>> listpair;
				BOOST_CHECK(ptestDataDictionaryControl->convertFromBLOBToPair(stBlob, listpair,true));
				BOOST_CHECK(listpair.size() > 0);

				cout << "  amount of elements in received listpair : " << listpair.size() << endl;
				cout << "  sequence Numbers decoded from DED into std::list :  ";
				cout << "*{{{" << endl;
				BOOST_FOREACH(auto &_pair, listpair)
				{
					seqSpan ss;
					ss = _pair.first;
					BOOST_FOREACH(auto &number, ss.seqNumbers)
					{
						cout << number << ",";
					}
					cout << endl;
						
					assembledElements _element;
					_element.strElementID = ss.attributPath; 
					_element.seqNumbers   = ss.seqNumbers;
					
					std::vector<assembledElements> vae = _pair.second;

					BOOST_FOREACH(auto &_element, vae) {
						CUtils::showDataBlock(true,true,_element.ElementData);
					}
				}
				cout << endl;
				cout << "*}}}" << endl;


				//resultFromRPCclients[n++] = AttributInblockSequenceFromBFifile;
				resultFromRPCclients[n++] = listpair;
				cout << "*}}}" << endl;
			}
		}
		cout << "*}}}" << endl;
		cout << "________________________________________" << endl;
		cout << "*** Merge retrieved RPCclient results with others " << endl;
		std::list< pair<seqSpan, std::vector<assembledElements>> > totallistOfAssembledAttributes;

		BOOST_FOREACH(auto &list, resultFromRPCclients) { totallistOfAssembledAttributes.insert(totallistOfAssembledAttributes.end(), list.begin(),list.end()); }

		pair<std::string, std::vector<unsigned char>> resultAttributPair = 	ptestDataDictionaryControl->mergeAndSort(attributToFetch, totallistOfAssembledAttributes);
		cout << "Attribut name : " << resultAttributPair.first << endl;
		BOOST_CHECK(attributToFetch == resultAttributPair.first);


		cout << "Original data : " << endl;
		CUtils::showDataBlock(true,true,FotoAttributValue);

		cout << "Result data : " << endl;
		bool bFoundError = CUtils::showDataBlockDiff(true,true,resultAttributPair.second, FotoAttributValue);
		if(!bFoundError) cout << "INFO: bytes assembled are equal to original " << endl;
		BOOST_CHECK(bFoundError == false);

		cout << "INFO: size of Original : " << FotoAttributValue.size() << ", size of result : " << resultAttributPair.second.size() << endl;
		int missingbytes = (FotoAttributValue.size() - resultAttributPair.second.size());

		if(missingbytes > 0) cout << "FAIL: Missing byte(s) : " << missingbytes << endl;
		BOOST_CHECK(FotoAttributValue.size() == resultAttributPair.second.size());

		BOOST_CHECK(FotoAttributValue == resultAttributPair.second); // verify that retrieved value is same as stored

		cout << "________________________________________" << endl;

		// Clean up section - must be in bottom
		BOOST_FOREACH(std::string filename, listBFiFiles)
		{
			cout << "- OK Cleanup file : " << filename << endl;
			boost::filesystem::path p = boost::filesystem::path(filename);
			boost::filesystem::remove(filename);
		}
		delete ptestDataDictionaryControl;
	}
	
	cout<<"}"<<endl;
}

*/

// DEPRECATED - somehow this does NOT release the file - causing next testcases to fail, thus it has been deprecated
// BOOST_AUTO_TEST_CASE(usingFuturesAsynchronReadFile)
// {
// 	cout << "BOOST_AUTO_TEST_CASE( usingFuturesAsynchronReadFile)\n{" << endl;
// 
// 	aio async_io;
// 	std::filebuf f;
// 	f.open("testImage.png",std::ios::in | std::ios::binary);
// 	std::future<std::vector<char> > fv=async_io.queue_read(f,1048576);
// 	CUtils::showDataBlock(true,true,fv.get());
// 
// 	cout << "}" << endl;
// }

std::runtime_error greatScott("Great Scott!");
void handler(int signum) {
	//cout << "SIGABRT: FAIL: error" << endl;
	throw greatScott;
}

using lambdaparams = std::vector<Variant>; 
BOOST_AUTO_TEST_CASE(testClass_collectablefutures)
{
	cout << "BOOST_AUTO_TEST_CASE( testClass_collectablefutures )\n{" << endl;
	collectablefutures cf;
	
	std::vector<unsigned char> result_buffer;

	BOOST_TEST_MESSAGE( "Instantiate collectablefutures class" );
	BOOST_REQUIRE(cf.getstate() == collectablefutures::enumstate::instantiated);

	BOOST_TEST_MESSAGE( "create request" );
	collectablefutures::request req = cf.createrequest();
	BOOST_CHECK_MESSAGE(cf.getstate() == collectablefutures::enumstate::preparing, "FAIL: when preparing");
	BOOST_CHECK_MESSAGE(req.runExec(result_buffer) == false, "FAIL: when running NULL executor");
	BOOST_TEST_MESSAGE( "add executor to request" );	

	Func f1 = [](lambdaparams i){ std::vector<unsigned char> result; cout << "- Hello from executor - function 1" << endl; return result; }; 
	req.addexecutorfunc( f1 );
	BOOST_CHECK_MESSAGE(cf.getstate() == collectablefutures::enumstate::executoradded, "FAIL: when adding executor");
	BOOST_TEST_MESSAGE( "run executor from request" );	
	BOOST_CHECK_MESSAGE(req.runExec(result_buffer) == true, "FAIL: when starting executor");
	BOOST_CHECK_MESSAGE(cf.getstate() == collectablefutures::enumstate::finishing, "FAIL: when running executor");
	
	BOOST_TEST_MESSAGE( "add one extra function to executor" );
	Func f2 = [](lambdaparams i){ std::vector<unsigned char> result; cout << "- Hello again from executor - function 2" << endl; return result; };
	req.addexecutorfunc( f2 );
	BOOST_CHECK_MESSAGE(req.getAmountExecutorFunctions() == 2, "FAIL: when adding extra function to executor");
	std::string msg = "starting executor with amount: " + std::to_string(req.getAmountExecutorFunctions()) + ", of functions "; 
	BOOST_TEST_MESSAGE( msg ); 
	BOOST_CHECK_MESSAGE(req.runExec(result_buffer) == true, "FAIL: when starting executor");

	BOOST_TEST_MESSAGE( "add request to collectablefutures request_queue - this should start thread " );
	cout << "amount of functions in requests executor : " << req.getAmountExecutorFunctions() << endl;
	cout << "Results from functions run from executor : " << endl;
	BOOST_CHECK_MESSAGE(req.getAmountExecutorFunctions() == 2, "FAIL: adding functions to executor failed");
	BOOST_CHECK_MESSAGE(cf.addRequestToQueue(req) == true, "FAIL: could not add to request queue");
	BOOST_CHECK_MESSAGE(cf.WaitForQueueSignalPop(1000) == true, "FAIL: timeout - waiting for functions to be popped from request queue to be run");

	boost::this_thread::sleep( boost::posix_time::milliseconds(1000) ); // above functions should not take longer to complete - this is to avoid cluttering up output
	
	BOOST_TEST_MESSAGE( "..." );
	BOOST_TEST_MESSAGE( "Now testing with future result from executor: " );

	// normal way of handling promise/future
	//std::promise<std::vector<unsigned char> > p;
	//std::future<std::vector<unsigned char> > f(p.get_future());

	// If old above req was used, then a future_error exception would be thrown, given that request future had already been accessed
	collectablefutures::request req2 = cf.createrequest();
	Func f3 = [](lambdaparams i){ std::vector<unsigned char> result; cout << "- Hello again from NEW executor - function 3" << endl; std::string s("HELLO WORLD"); result.insert(result.end(),s.begin(), s.end()); return result; };
	req2.addexecutorfunc( f3 );
	BOOST_TEST_MESSAGE( "1. runRequest will take request and it will take its internal promise and add its future to a result vector buffer" );
	std::future<std::vector<unsigned char>> future_result_from_executor = cf.runRequest( req2 );
	BOOST_TEST_MESSAGE( "2. now wait for it to be finished" );
	future_result_from_executor.wait();
	BOOST_TEST_MESSAGE( "3. then get its result" );
	auto result = future_result_from_executor.get();
	BOOST_TEST_MESSAGE( "4. verify the result" );
	CUtils::showDataBlock(true,true,result);
	std::string s(result.begin(), result.end());
	BOOST_CHECK_MESSAGE(s == "HELLO WORLD", "FAIL: corrupted data from future" );


	BOOST_TEST_MESSAGE( "5. Try new function that reads an image file and returns it as vector buffer" );
	std::vector<unsigned char> origFotoAttributValue;
	std::string fn = "testImage.png"; // should be of size 10.5 Kb
	std::ifstream is (fn, ios::binary);
	if (is)
	{
		long length = boost::filesystem::file_size(fn);
		// Make sure receipient has room
		origFotoAttributValue.resize(length,0);
		//read content of infile
		is.read ((char*)&origFotoAttributValue[0],length);
		is.close();
	}

	Func f4 = [](lambdaparams i){
		std::vector<unsigned char> FotoAttributValue;
		std::string fn = "testImage.png"; // should be of size 10.5 Kb
		std::ifstream is (fn, ios::binary);
		if (is)
		{
			long length = boost::filesystem::file_size(fn);
			std::cout << "[readFile] Reading file: " << fn << " ; amount " << length << " characters... \n";
			// Make sure receipient has room
			FotoAttributValue.resize(length,0);
			//read content of infile
			is.read ((char*)&FotoAttributValue[0],length);
			//std::cout << "[readFile] size: " << (int) FotoAttributValue.size() << '\n';
			//std::cout << "[readFile] capacity: " << (int) FotoAttributValue.capacity() << '\n';
			//std::cout << "[readFile] max_size: " << (int) FotoAttributValue.max_size() << '\n';
			is.close();
		}
		return FotoAttributValue;	
	};
	collectablefutures::request req3 = cf.createrequest();
	req3.addexecutorfunc( f4 );
	std::future<std::vector<unsigned char>> future_result_image = cf.runRequest( req3 );
	BOOST_TEST_MESSAGE( "6. now wait for it to be finished" );
	future_result_image.wait();
	auto resultimage = future_result_image.get();
	BOOST_TEST_MESSAGE( "7. verify the result" );
	BOOST_CHECK_MESSAGE(CUtils::showDataBlockDiff(true,true,resultimage, origFotoAttributValue) == false, "FAIL: result differs from original");


	
	BOOST_TEST_MESSAGE( "Try to create multiple requests, each having one function,  and waiting for future result : " );

	Func f5 = [](lambdaparams i){ std::vector<unsigned char> result; cout << "- Hello from executor - function 5  " << endl; std::string s("HELLO EARTH"); result.insert(result.end(),s.begin(), s.end()); return result; };

	collectablefutures::request req4 = cf.createrequest();
	req4.addexecutorfunc( 8, f5 );
	
	auto f6 = [](std::vector<Variant> vec){ 	
										std::vector<unsigned char> result; 
										cout << "- Hello from executor - function 6 "; 
										std::cout << ": parameters : ";
										for(auto a: vec) {
											std::cout << a << ",";	
										}
										std::cout << std::endl;
										std::string s("HELLO UNIVERSE"); 
										result.insert(result.end(),s.begin(), s.end()); 
										return result; 
	};
		
	collectablefutures::request req5 = cf.createrequest();
	req5.addexecutorfunc( 10, f6 );

	auto f7 = [](std::vector<Variant> vec){ 	
		std::vector<unsigned char> result; 
		cout << "- Hello from executor - function 7 "; 
		std::cout << ": parameters : ";
		for(auto a: vec) {
			std::cout << a << ",";	
		}
		std::cout << std::endl;
		std::string s("HELLO GALAXY"); 
		result.insert(result.end(),s.begin(), s.end()); 
		return result; 
	};

	collectablefutures::request req6 = cf.createrequest();
	req6.addexecutorfunc( f7, 10,11,"hello there" );

	auto fnTest = [](std::vector<Variant> vec){ 	
		std::vector<unsigned char> result; 
		cout << "- Hello from executor - function fnTest "; 
		std::cout << ": parameters : ";
		for(auto a: vec) {
			std::cout << a << ",";	
		}
		std::cout << std::endl;
		std::string s("HELLO MULTIVERSE"); 
		result.insert(result.end(),s.begin(), s.end()); 
		return result; 
	};
	collectablefutures::request reqX = cf.createrequest();
	reqX.addexecutorfunc( fnTest, 20,21,"h" );


	std::vector< std::future<std::vector<unsigned char>> >  collectionOfFutureRequests;
	cf.runRequest( req4, collectionOfFutureRequests );
	cf.runRequest( req5, collectionOfFutureRequests );
	cf.runRequest( req6, collectionOfFutureRequests );
	cf.runRequest( reqX, collectionOfFutureRequests );
//	std::vector<unsigned char> result_complete;
	try{
		//void (*original_handler)(int) = signal(SIGABRT, handler);
	auto result_complete = cf.collect(collectionOfFutureRequests);

	BOOST_TEST_MESSAGE( "Verify the result" );
	std::vector<unsigned char> result_compare;
	std::string scompare("HELLO EARTHHELLO UNIVERSEHELLO GALAXYHELLO MULTIVERSE"); 
	result_compare.insert(result_compare.end(),scompare.begin(), scompare.end());
	BOOST_CHECK_MESSAGE(CUtils::showDataBlockDiff(true,true,result_complete, result_compare) == false, "FAIL: result differs from original");
	}catch(...){ cout << "Houston we have a problem " << endl; }

	CUtils::terminalGraph(); // tst


/////////
	BOOST_TEST_MESSAGE( "Try a new collectablefuture instance " );

	Func fnTest2 = [](std::vector<Variant> vec){ 	
		std::vector<unsigned char> result = std::vector<unsigned char>(); 
		cout << "- Hello from executor - function fnTest2 "; 
		std::cout << ": parameters : ";
		for(auto a: vec) {
			std::cout << a << ",";	
		}
		std::cout << std::endl;
		std::string s("HELLO MULTIVERSE"); 
		result.insert(result.end(),s.begin(), s.end()); 
		return result; 
	};
	collectablefutures cf2;

	collectablefutures::request reqX2 = cf2.createrequest();
	reqX2.addexecutorfunc( fnTest2, 20,21,"help" );
	
	BOOST_TEST_MESSAGE( "Run request" );
	std::vector< std::future<std::vector<unsigned char>> >  collectionOfFutureRequests2;
	cf2.runRequest( reqX2, collectionOfFutureRequests2 );
	BOOST_TEST_MESSAGE( "Collect result" );
	std::vector<unsigned char> result_complete2 = cf2.collect(collectionOfFutureRequests2);

	BOOST_TEST_MESSAGE( "Verify the result" );
	std::vector<unsigned char> result_compare2;
	std::string scompare2("HELLO MULTIVERSE"); 
	result_compare2.insert(result_compare2.end(),scompare2.begin(), scompare2.end());
	BOOST_CHECK_MESSAGE(CUtils::showDataBlockDiff(true,true,result_complete2, result_compare2) == false, "FAIL: result differs from original");

	BOOST_TEST_MESSAGE( "Again Try yet a new collectablefuture instance " );


	Func fnTest3 = [](std::vector<Variant> vec){ 	
		std::vector<unsigned char> result = std::vector<unsigned char>(); 
		cout << "- Hello from executor - function fnTest3 "; 
		std::cout << ": parameters : ";
		for(auto a: vec) {
			std::cout << a << ",";	
		}
		std::cout << std::endl;
		std::string s("HELLO miniverse"); 
		result.insert(result.end(),s.begin(), s.end()); 
		return result; 
	};
	collectablefutures cf3;

	collectablefutures::request reqX3 = cf3.createrequest();
	reqX3.addexecutorfunc( fnTest3, 43,41,"Heeelp" );
	BOOST_TEST_MESSAGE( "Run request" );
	std::vector< std::future<std::vector<unsigned char>> >  collectionOfFutureRequests3;
	cf3.runRequest( reqX3, collectionOfFutureRequests3 );
	BOOST_TEST_MESSAGE( "Collect result" );
	std::vector<unsigned char> result_complete3 = cf3.collect(collectionOfFutureRequests3);
	
	BOOST_TEST_MESSAGE( "Verify the result" );
	std::vector<unsigned char> result_compare3;
	std::string scompare3("HELLO miniverse"); 
	result_compare3.insert(result_compare3.end(),scompare3.begin(), scompare3.end());
	BOOST_CHECK_MESSAGE(CUtils::showDataBlockDiff(true,true,result_complete3, result_compare3) == false, "FAIL: result differs from original");

	cout << "}" << endl;
}

template<typename T>
void boring_template_fn(T t){
	auto identity = [](decltype(t) t){ return t;};
	std::cout << identity(t) << std::endl;
}


BOOST_AUTO_TEST_CASE(lambdaWithParameters)
{
	cout << "BOOST_AUTO_TEST_CASE( lambdaWithParameters )\n{" << endl;

	//auto lambda = [](auto... args) { cout << "hello world" << ... << endl; };
	//auto lambda = [](...) { int a=1; va_list args; va_start(args,0); auto b = va_arg(args, int); cout << "hello world " << b << endl; va_end(args); };
	auto lambda = [](...) 
	{ 
		va_list args; 
		va_start(args,0); 
		auto b = va_arg(args, const char*);
		cout << "hello world " << b << endl; 
		va_end(args);
	};

	try {
		lambda();
		lambda("hej");
		//lambda(5);
	}
	catch(...)
	{
		cout << "unknown type of argument" << endl;
	} 

	auto weird_lambda = [](auto... param) {
		Store<decltype(param)...> stream;
		using List = int[];
		(void)List{ 0, ((void)(stream .add(param)), 0) ... };
		return stream;
	};
	std::cout << weird_lambda(1,"abc", 2.34, 3,"qwe").get<int>()[1] << endl;

	//std::function<std::vector<unsigned char>(auto... args)> f5 = [](auto... args){ std::vector<unsigned char> result; cout << "- Hello from executor - function 5" << endl; std::string s("HELLO EARTH"); result.insert(result.end(),s.begin(), s.end()); return result; };
	auto f5 = [](auto... param){ 
		std::vector<unsigned char> result; cout << "- Hello from executor - function 5 : "  << endl; std::string s("HELLO EARTH"); result.insert(result.end(),s.begin(), s.end()); return result; 
	};

	f5();
	f5("hello");


	//auto f6 = [](auto&&...args) -> decltype(auto) { return simpleAdd(decltype(args)(args)...); };
	//cout << f6() << endl;

	auto head = [](auto... args ) {
		    return [](auto first, auto ...rest) { return first; };
	};

	auto list = [](auto ...xs) {
		return [=](auto access) { return access(xs...); };
	};

	//cout << " head lambda : result: " << head("first", "second", "3") << endl;

	auto lambda2 = [](const auto&...args)
	{
		std::cout << "hello ";
		const int dummy[] = {0, ((std::cout << args), 0)...};
		static_cast<void>(dummy);
		std::cout << std::endl;
	};

	lambda2("world", " and ", "universe");
	lambda2(1);

	auto lambda3 = [](const auto&...args)
	{
		std::vector<std::string> v;
		std::cout << "hello ";
		const int dummy[] = {0, ((v.push_back(args)), 0)...};
		std::cout << std::endl;
		return v;
	};

	std::vector<std::string> v = lambda3("world");
	cout << "size of vector received: " << v.size() << endl;
	cout << "content of vector : " << v[0] << endl;

	typedef boost::variant<int, float, std::string> Variant;
	auto lambda4 = [](const auto&...args)
	{
		//std::vector<Variant> vec;
		//const int dummy[] = {0, ((vec.push_back(args)), 0)...};
		std::vector<Variant> vec = {args...}; 
		return vec;
	};

	std::vector<Variant> v4 = lambda4("world", " and ", "universe");
	cout << "size of vector received: " << v4.size() << endl;
	cout << "content of vector : " << v4[0] << v4[1]<< v4[2]  << endl;


	auto _lambda = [](const auto&...args)
	{
		typedef boost::variant<int, float, std::string> Variant;
		std::vector<Variant> vec = {args...}; 
		std::cout << "hello ";
		for(auto a: vec) {
			std::cout << a;	
		}
		std::cout << std::endl;
	};

	_lambda("world", " and ", "universe");

	// c++17 - however it does not work !? fold expressions - how to use it?
	// auto lambda_c17 = [](const auto&...args)
	// {
	// 	 (std::cout << ... << args) << '\n';
	// };

	// lambda_c17("world");
	// lambda_c17(1);

	//print_1("hello ", "world");


	std::function<void(int)> f = [] (int i) 
	{ 
		std::cout << "The answer is " << i; 
	};
	f(42);
	cout << endl;

	std::string s("My string");
	boring_template_fn(s);
	boring_template_fn(1024);
	boring_template_fn(true);
	cout << endl;


	cout << "}" << endl;
}

BOOST_AUTO_TEST_CASE(fetchAttributFrom_3_virtual_RPCclients_using_Futures)
{
	cout<<"BOOST_AUTO_TEST_CASE( fetchAttributFrom_3_virtual_RPCclients_using_Futures)\n{"<<endl;

	using boost::optional;
	using boost::property_tree::ptree;

	CDataDictionaryControl *pDDC = new CDataDictionaryControl();
	std::list<std::string> listResult = pDDC->ls();	
	BOOST_FOREACH(std::string attribut, listResult) { cout << "- OK attribut : " << attribut << endl; }
	BOOST_CHECK(listResult.size() <= 0);
	BOOST_WARN_MESSAGE(listResult.size() <= 0, "Failure since - no .BFi file should be present ");

	if(listResult.size() <= 0) {

		CDataDictionaryControl *ptestDataDictionaryControl = new CDataDictionaryControl();
		ptree ptListOfBlockRecords;

		// attribut 3
		std::string attributName = "name";
		std::string name = "Johnny Serup";	
		std::vector<unsigned char> attributValue(name.begin(), name.end());

		// attribut 2
		std::string attributName2 = "mobil";
		std::string mobil = "555 - 332 211 900";	
		std::vector<unsigned char> attributValue2(mobil.begin(), mobil.end());

		// attribut 1 - large
		std::string FotoAttributName= "foto"; // it should be ddid -- datadictionary id which refers to attribut description
		std::vector<unsigned char> FotoAttributValue;
		std::string fn = "testImage.png"; // should be of size 10.5 Kb
		std::ifstream is (fn, ios::binary);
		if (is)
		{
			long length = boost::filesystem::file_size(fn);
			std::cout << "[readFile] Reading file: " << fn << " ; amount " << length << " characters... \n";
			// Make sure receipient has room
			FotoAttributValue.resize(length,0);
			//read content of infile
			is.read ((char*)&FotoAttributValue[0],length);
			is.close();
		}
		BOOST_CHECK(FotoAttributValue.size() > 0);

		std::string realmName = "profile";
		long maxBlockRecordSize=5456; // should result in multiple BlockRecords inside a BlockEntity	


		cout << "BlockRecord size before: " << maxBlockRecordSize << endl;
		std::string transGuid = "F8C23762ED2823A27E62A64B95C024EE";
		BOOST_CHECK(ptestDataDictionaryControl->addAttributToBlockRecord(transGuid,ptListOfBlockRecords, maxBlockRecordSize, realmName, FotoAttributName, FotoAttributValue)); 
		cout << "BlockRecord size after 1 attribut add : " << maxBlockRecordSize << endl;
		BOOST_CHECK(ptestDataDictionaryControl->addAttributToBlockRecord(transGuid,ptListOfBlockRecords, maxBlockRecordSize, realmName, attributName2, attributValue2)); 
		cout << "BlockRecord size after 2 atrribut add : " << maxBlockRecordSize << endl;
		BOOST_CHECK(ptestDataDictionaryControl->addAttributToBlockRecord(transGuid,ptListOfBlockRecords, maxBlockRecordSize, realmName, attributName, attributValue)); 
		cout << "BlockRecord size after 3 atrribut add : " << maxBlockRecordSize << endl;

		long maxBlockEntitySize=10000; // should result in 3 BlockEntity 	
		boost::property_tree::ptree ptBlockEntity = ptestDataDictionaryControl->addBlockRecordToBlockEntity(transGuid, ptListOfBlockRecords, maxBlockEntitySize);
		BOOST_CHECK(ptBlockEntity.size()>0);

		// create BFi files
		std::vector< pair<std::string ,int> > listOfBlockEntityFiles = ptestDataDictionaryControl->writeBlockEntityToBFiFile(ptBlockEntity);
		cout << "Created : " << listOfBlockEntityFiles.size() << " .BFi files " << endl;
		BOOST_CHECK(listOfBlockEntityFiles.size()==3);

		pair <std::string,int> block;
		std::list<std::string> listBFiFiles;
		BOOST_FOREACH(block, listOfBlockEntityFiles)
		{
			cout << "- OK Created file : " << block.first << " size : " << block.second << endl;
			listBFiFiles.push_back(block.first);
		}

		// check that list now contain basic 'listOfBlockRecords' - which is necessary	
		optional< ptree& > child = ptListOfBlockRecords.get_child_optional( "listOfBlockRecords" );
		BOOST_CHECK(child);

		// verify that BlockRecord has been added
		child = ptListOfBlockRecords.get_child_optional( "BlockRecord.chunk_data" );
		BOOST_CHECK(child);

		child = ptListOfBlockRecords.get_child_optional( "BlockRecord.chunk_data.chunk_record" );
		BOOST_CHECK(child);

		child = ptListOfBlockRecords.get_child_optional( "BlockRecord.chunk_data.chunk_record.chunk_ddid" );
		BOOST_CHECK(child);

		cout << "________________________________________" << endl;
		cout << "attributs added : " << endl;

		int amountOfBlockRecords = 0;
		int amountOfchunk_records = 0;
		std::string hexdata_attribut1="";
		std::string hexdata_attribut2="";


		BOOST_FOREACH(ptree::value_type &vt, ptListOfBlockRecords.get_child("listOfBlockRecords"))
		{
			cout << " - record id : " << vt.second.get_child("chunk_id").data() << endl;
			if(vt.first == "BlockRecord")
			{
				amountOfBlockRecords++;
				BOOST_FOREACH(ptree::value_type &vt2 , vt.second)
				{
					if(vt2.first == "chunk_data")
					{
						cout << " - " << vt2.first << " : "; 
						std::string attributName="";
						std::string prevattributName="";
						BOOST_FOREACH(ptree::value_type &vt3, vt2.second)
						{
							if(vt3.first == "chunk_record") {
								attributName = vt3.second.get_child("chunk_ddid").data();
								if(prevattributName!=attributName) {
									cout << endl;
									cout << " -- chunk_record : " << vt3.second.get_child("chunk_ddid").data() << " "; 
									prevattributName=attributName;
								}
								else
									cout << ".";
								amountOfchunk_records++;
								if(amountOfchunk_records==1) {
									hexdata_attribut1 = vt3.second.get_child("Data").data();
								}
								if(amountOfchunk_records==2) {
									hexdata_attribut2 = vt3.second.get_child("Data").data();
								}
							}
						}
					}
				}
			}
			cout << endl;
		}

		cout << "________________________________________" << endl;
		if(amountOfBlockRecords==3)
			cout << "- OK amount of BlockRecords created: " << amountOfBlockRecords << endl;
		else
			cout << "- FAIL: amount of BlockRecords created: " << amountOfBlockRecords << endl;
		BOOST_CHECK(amountOfBlockRecords == 3); // Only one BlockRecord - the attributs should be added to BlockRecord until it is full, then new BlockRecord will be added
		if(amountOfchunk_records == 37)
			cout << "- OK amount of chunk records : " << amountOfchunk_records << endl;
		else
			cout << "- FAIL: amount of chunk records : " << amountOfchunk_records << endl;
		BOOST_CHECK(amountOfchunk_records == 37); // 35 for foto, 1 for mobil, and 1 for name
		cout << "________________________________________" << endl;

		cout << "call ls() - list attributs - validate expected results " << endl;
		listResult = pDDC->ls();	
		//expected : reads like this: <GUID> has a profile folder with attribut name, mobil and foto
		std::string expected1 =  transGuid + "./profile/foto";
		std::string expected2 =  transGuid + "./profile/mobil";
		std::string expected3 =  transGuid + "./profile/name";

		BOOST_CHECK(listResult.size() > 0);

		int c=0;
		BOOST_FOREACH(std::string attribut, listResult)
		{
			c++;
			cout << "- OK attribut : " << attribut << endl;
			if(c==1) BOOST_CHECK(expected1 == attribut);
			if(c==2) BOOST_CHECK(expected2 == attribut);
			if(c==3) BOOST_CHECK(expected3 == attribut);
		}

		cout << "TODO: ls should show attribut spanning over multiple .BFi files in a different way " << endl;

		cout << "________________________________________" << endl;

		cout << "*** SIMULATE creating Promises for .BFi file's from RPC's and get Future results when ready" << endl;
		cout << "*{{{" << endl;
		std::string attributToFetch = transGuid + "./profile/foto";
		std::vector<std::list< pair<seqSpan, std::vector<assembledElements>>>> resultFromRPCclients (3); // testcase has only 3 virtual RPCclients delivering results
		
		int n=0;

		// iterate .BFi files - create a promise for handling each .BFi file
		std::vector< std::future<std::vector<unsigned char>> >  collectionOfFutureRequests;


		// create function for fetching attributs from .BFi file
		auto fnFetchAllAttributsFromBFiFile = [](std::vector<Variant> vec){ 	
			//std::vector<unsigned char> result; 
			//cout << "- Hello from executor - function fnFetchAllAttributsFromBFiFile "; 
			cout << "*{{{" << endl;
			//std::cout << "parameters : ";
			//for(auto a: vec) {
			//	std::cout << a << ",";	
			//}
			//std::cout << std::endl;
			
			//cout << "First param : " << boost::get<std::string>(vec[0]) << endl;	
			boost::filesystem::path currentfile( boost::filesystem::path(boost::get<std::string>(vec[0])) );
			//cout << "currentfile : " << currentfile.string() << endl;
			CDataDictionaryControl DDC;
			std::list<pair<seqSpan, std::vector<assembledElements>>> AttributInblockSequenceFromBFifile;
			//cout << "  Fetch attributs from .BFi file " << endl;
			DDC.fetchAttributsFromFile(currentfile, AttributInblockSequenceFromBFifile); 
			//cout << "  prepare result in a BLOB " << endl;
			transferBLOB stBlob = DDC.convertToBLOB(AttributInblockSequenceFromBFifile,true);
			cout << "*}}}" << endl;
			return stBlob.data;	
			
			//cout << "*}}}" << endl;
			//return result;
		};
		
		
		collectablefutures cf;

		std::string file1 = transGuid + "_1.BFi";
		std::string file2 = transGuid + "_2.BFi";
		std::string file3 = transGuid + "_3.BFi";
		collectablefutures::request req1 = cf.createrequest();
		collectablefutures::request req2 = cf.createrequest();
		collectablefutures::request req3 = cf.createrequest();
		req1.addexecutorfunc( fnFetchAllAttributsFromBFiFile, file1 );
		req2.addexecutorfunc( fnFetchAllAttributsFromBFiFile, file2 );
		req3.addexecutorfunc( fnFetchAllAttributsFromBFiFile, file3 );
		
		cf.runRequest( req1, collectionOfFutureRequests ); // fetch attributs data from .BFi file 
		cf.runRequest( req2, collectionOfFutureRequests ); // fetch attributs data from .BFi file 
		cf.runRequest( req3, collectionOfFutureRequests ); // fetch attributs data from .BFi file 

/*
	auto fnTest = [](std::vector<Variant> vec){ 	
			std::vector<unsigned char> result; 
			cout << "- Hello from executor - function fnTest "; 
			std::cout << ": parameters : ";
			for(auto a: vec) {
				std::cout << a << ",";	
			}
			std::cout << std::endl;
			std::string s("HELLO MULTIVERSE"); 
			result.insert(result.end(),s.begin(), s.end()); 
			return result; 
		};

		collectablefutures::request reqX = cf.createrequest();
		reqX.addexecutorfunc( fnTest, 20,21,"h" );
	
		cf.runRequest( reqX, collectionOfFutureRequests );
	
		auto result_complete = cf.collect(collectionOfFutureRequests);
*/
	
	/*
		boost::filesystem::path currentSearchDirectory( boost::filesystem::current_path() );
		boost::filesystem::recursive_directory_iterator directoryIterator(currentSearchDirectory), eod;
		n=0;
		BOOST_FOREACH(boost::filesystem::path const& currentfile, make_pair(directoryIterator, eod))
		{
			std::list<pair<seqSpan, std::vector<assembledElements>>> AttributInblockSequenceFromBFifile;
			if((boost::filesystem::extension(currentfile.string()) == BFI_FILE_EXTENSION)) 
			{ 
				cout << "files : " << currentfile.string() << ", ";
				collectablefutures::request req = cf.createrequest();
				req.addexecutorfunc( fnFetchAllAttributsFromBFiFile, currentfile.string() );
				cf.runRequest( req, collectionOfFutureRequests ); // fetch attributs data from .BFi file 
			}
		}
		cout << endl;	
*/
		// not possible yet - since result for each first needs to be sorted
//		auto result_complete = cf.collect(collectionOfFutureRequests); // should contain complete attribut - combined result from the 3 clients

		n=0;
		for ( auto &f: collectionOfFutureRequests)
		{
			cout << "WAIT for completion of request " << endl;
			f.wait(); // wait for function in future request to finish
			cout << "fetch result from request " << endl;
			auto result_request = f.get(); 
			// transfer result to a transferBLOB structure
			transferBLOB stBLOB;
			stBLOB.eType = transferBLOB::enumType::ATTRIBUTS_LIST;
			stBLOB.size = result_request.size();
			stBLOB.data = std::move(result_request);
	
			// transfer/convert to listpair
			std::list<pair<seqSpan, std::vector<assembledElements>>> listpair;
			ptestDataDictionaryControl->convertFromBLOBToPair(stBLOB, listpair,true);

			//+ DEBUG show data
			cout << "Amount of elements in received listpair : " << listpair.size() << endl;
			cout << "*{{{" << endl;
			BOOST_FOREACH(auto &_pair, listpair)
			{
				seqSpan ss;
				ss = _pair.first;
				BOOST_FOREACH(auto &number, ss.seqNumbers)
				{
					cout << number << ",";
				}
				cout << endl;

				assembledElements _element;
				_element.strElementID = ss.attributPath; 
				_element.seqNumbers   = ss.seqNumbers;

				std::vector<assembledElements> vae = _pair.second;

				BOOST_FOREACH(auto &_element, vae) {
					CUtils::showDataBlock(true,true,_element.ElementData);
				}
			}
			cout << endl;
			cout << "*}}}" << endl;
			//- DEBUG show data

			resultFromRPCclients[n++] = listpair;

		}

		cout << "*}}}" << endl;

		/*
		cout << "*** SIMULATE that parsing result of .BFi files comes from 3 different RPCclients" << endl;
		cout << "*{{{" << endl;
		std::string attributToFetch = transGuid + "./profile/foto";
		
		std::vector<std::list< pair<seqSpan, std::vector<assembledElements>>>> resultFromRPCclients (3); // testcase has only 3 virtual RPCclients delivering results
	
		boost::filesystem::path currentSearchDirectory( boost::filesystem::current_path() );
		boost::filesystem::recursive_directory_iterator directoryIterator(currentSearchDirectory), eod;

		int n=0;
		BOOST_FOREACH(boost::filesystem::path const& currentfile, make_pair(directoryIterator, eod))
		{
			std::list<pair<seqSpan, std::vector<assembledElements>>> AttributInblockSequenceFromBFifile;


			if((boost::filesystem::extension(currentfile.string()) == BFI_FILE_EXTENSION)) { 
				cout << "virtual RPCclient " << n+1 << " : " << endl;
				cout << "*{{{" << endl;
				cout << "  Fetch attribut from .BFi file " << endl;
				ptestDataDictionaryControl->fetchAttributsFromFile(currentfile, AttributInblockSequenceFromBFifile); 

				cout << "  prepare result in a BLOB " << endl;
				transferBLOB stBlob = ptestDataDictionaryControl->convertToBLOB(AttributInblockSequenceFromBFifile,true);
				BOOST_CHECK(stBlob.eType == transferBLOB::enumType::ATTRIBUTS_LIST);
				
				cout << "  simulate transfer / receive from RPCclient to server " << endl;
				cout << "  convert result in BLOB to list pair<seq,vector<assembledElements>> " << endl;
				
				std::list<pair<seqSpan, std::vector<assembledElements>>> listpair;
				BOOST_CHECK(ptestDataDictionaryControl->convertFromBLOBToPair(stBlob, listpair,true));
				BOOST_CHECK(listpair.size() > 0);

				cout << "  amount of elements in received listpair : " << listpair.size() << endl;
				cout << "  sequence Numbers decoded from DED into std::list :  ";
				cout << "*{{{" << endl;
				BOOST_FOREACH(auto &_pair, listpair)
				{
					seqSpan ss;
					ss = _pair.first;
					BOOST_FOREACH(auto &number, ss.seqNumbers)
					{
						cout << number << ",";
					}
					cout << endl;
						
					assembledElements _element;
					_element.strElementID = ss.attributPath; 
					_element.seqNumbers   = ss.seqNumbers;
					
					std::vector<assembledElements> vae = _pair.second;

					BOOST_FOREACH(auto &_element, vae) {
						CUtils::showDataBlock(true,true,_element.ElementData);
					}
				}
				cout << endl;
				cout << "*}}}" << endl;


				//resultFromRPCclients[n++] = AttributInblockSequenceFromBFifile;
				resultFromRPCclients[n++] = listpair;
				cout << "*}}}" << endl;
			}
		}
		cout << "*}}}" << endl;
		cout << "________________________________________" << endl;

		*/

		cout << "*** Merge retrieved RPCclient results with others " << endl;
		std::list< pair<seqSpan, std::vector<assembledElements>> > totallistOfAssembledAttributes;

		BOOST_FOREACH(auto &list, resultFromRPCclients) { totallistOfAssembledAttributes.insert(totallistOfAssembledAttributes.end(), list.begin(),list.end()); }

		pair<std::string, std::vector<unsigned char>> resultAttributPair = 	ptestDataDictionaryControl->mergeAndSort(attributToFetch, totallistOfAssembledAttributes);
		cout << "Attribut name : " << resultAttributPair.first << endl;
		BOOST_CHECK(attributToFetch == resultAttributPair.first);


		cout << "Original data : " << endl;
		CUtils::showDataBlock(true,true,FotoAttributValue);

		cout << "Result data : " << endl;
		bool bFoundError = CUtils::showDataBlockDiff(true,true,resultAttributPair.second, FotoAttributValue);
		if(!bFoundError) cout << "INFO: bytes assembled are equal to original " << endl;
		BOOST_CHECK(bFoundError == false);

		cout << "INFO: size of Original : " << FotoAttributValue.size() << ", size of result : " << resultAttributPair.second.size() << endl;
		int missingbytes = (FotoAttributValue.size() - resultAttributPair.second.size());

		if(missingbytes > 0) cout << "FAIL: Missing byte(s) : " << missingbytes << endl;
		BOOST_CHECK(FotoAttributValue.size() == resultAttributPair.second.size());

		BOOST_CHECK(FotoAttributValue == resultAttributPair.second); // verify that retrieved value is same as stored

		cout << "________________________________________" << endl;

		// Clean up section - must be in bottom
		BOOST_FOREACH(std::string filename, listBFiFiles)
		{
			cout << "- OK Cleanup file : " << filename << endl;
			boost::filesystem::path p = boost::filesystem::path(filename);
			boost::filesystem::remove(filename);
		}
		delete ptestDataDictionaryControl;
	}
	
	cout<<"}"<<endl;
}


#ifdef FOLLY

/**
 * TODO: create a testcase which creates futures and executers - where executers simulate RPCclients
 * see example : https://code.facebook.com/posts/1661982097368498/futures-for-c-11-at-facebook/
 *
 * using: 
 * https://github.com/facebook/folly/tree/master/folly/futures
 */
struct Executor {
	using Func = std::function<void()>;
	virtual void add(Func) = 0;
};

std::runtime_error greatScott("Great Scott!");
double getEnergySync(int year) {
	if (year == 1955 || year == 1885) throw greatScott;
	return 1.21e9;
}

Future<double> getEnergy(int year) {
	auto promise = make_shared<Promise<double>>();

	std::thread([=]{
			promise->setWith(std::bind(getEnergySync, year));
			}).detach();

	return promise->getFuture();
}

BOOST_AUTO_TEST_CASE(testFollyFutures)
{
	cout << "BOOST_AUTO_TEST_CASE( testFollyFutures )\n{" << endl;

	// First create a promise
	Promise<double> promise;
	Future<double> future = promise.getFuture();



	// fullfill the promise
	promise.setValue(1.21e9);
	promise.setException(greatScott);
	promise.setWith([]{ if (year == 1955 || year == 1885) throw greatScott; return 1.21e9; });


	//Future<double> future = folly::via(Executor, std::bind(getEnergySync, 2017));


	BOOST_CHECK(true == false);

	cout << "}" << endl;
}

BOOST_AUTO_TEST_CASE(useFuturesToCollectRPCclientsResults)
{
	cout << "BOOST_AUTO_TEST_CASE( useFuturesToCollectRPCclientsResults )\n{" << endl;

	BOOST_CHECK(true == false);

	cout << "}" << endl;
}

#endif // FOLLY

// ******************************************************************************************************************
// BASIC ZooKeeper connection example :
// ******************************************************************************************************************
//
// to start local zookeeper for running integration tests:
// /opt/zookeeper-3.4.8/bin/zkServer.sh start
//
//
/** integrationTest_connectTo_zookeeper_basic :
 * for a better example please see : https://apache.googlesource.com/zookeeper/+/trunk/src/c/src/cli.c
 *
 *  In this example this method gets the cert for your
 *  environment -- you must provide
 */
char *foo_get_cert_once(char* id) { return 0; }

/** Watcher function -- empty for this example, not something you should
 *  do in real code */
//void watcher(zhandle_t *zzh, int type, int state, const char *path,
//		void *watcherCtx) {}

#define _LL_CAST_ (long long)
static zhandle_t *zh;
static clientid_t myid;
static const char *clientIdFile = 0;
static const char* state2String(int state){
	if (state == 0) //ZOO_CLOSED_STATE
		return "CLOSED_STATE";
	if (state == ZOO_CONNECTING_STATE)
		return "CONNECTING_STATE";
	if (state == ZOO_ASSOCIATING_STATE)
		return "ASSOCIATING_STATE";
	if (state == ZOO_CONNECTED_STATE)
		return "CONNECTED_STATE";
	//if (state == ZOO_READONLY_STATE)
	//	return "READONLY_STATE";
	if (state == ZOO_EXPIRED_SESSION_STATE)
		return "EXPIRED_SESSION_STATE";
	if (state == ZOO_AUTH_FAILED_STATE)
		return "AUTH_FAILED_STATE";
	return "INVALID_STATE";
}
static const char* type2String(int state){
	if (state == ZOO_CREATED_EVENT)
		return "CREATED_EVENT";
	if (state == ZOO_DELETED_EVENT)
		return "DELETED_EVENT";
	if (state == ZOO_CHANGED_EVENT)
		return "CHANGED_EVENT";
	if (state == ZOO_CHILD_EVENT)
		return "CHILD_EVENT";
	if (state == ZOO_SESSION_EVENT)
		return "SESSION_EVENT";
	if (state == ZOO_NOTWATCHING_EVENT)
		return "NOTWATCHING_EVENT";
	return "UNKNOWN_EVENT_TYPE";
}

boost::condition cndSignalEvent;
boost::mutex mtxEventWait;
bool WaitForEvent(long milliseconds)
{
	boost::mutex::scoped_lock mtxWaitLock(mtxEventWait);
	boost::posix_time::time_duration wait_duration = boost::posix_time::milliseconds(milliseconds); 
	boost::system_time const timeout=boost::get_system_time()+wait_duration; 
	return cndSignalEvent.timed_wait(mtxEventWait,timeout); // wait until signal Event 
}

// Watcher function -- basic handling
void watcher(zhandle_t *zzh, int type, int state, const char *path, void* context)
{
	/* Be careful using zh here rather than zzh - as this may be mt code
	 * the client lib may call the watcher before zookeeper_init returns */
	fprintf(stdout, "Watcher %s state = %s", type2String(type), state2String(state));
	if (path && strlen(path) > 0) {
		fprintf(stderr, " for path %s", path);
	}
	fprintf(stdout, "\n");
	if (type == ZOO_SESSION_EVENT) {
		if (state == ZOO_CONNECTED_STATE) {
			const clientid_t *id = zoo_client_id(zzh);
			if (myid.client_id == 0 || myid.client_id != id->client_id) {
				myid = *id;
				fprintf(stdout, "Got a new session id: 0x%llx\n", _LL_CAST_ myid.client_id);
				cndSignalEvent.notify_one(); // signal that connection was established
			}
		} else if (state == ZOO_AUTH_FAILED_STATE) {
			fprintf(stdout, "Authentication failure. Shutting down...\n");
			zookeeper_close(zzh);
			zh=0;
		} else if (state == ZOO_EXPIRED_SESSION_STATE) {
			fprintf(stdout, "Session expired. Shutting down...\n");
			zookeeper_close(zzh);
			zh=0;
		}
	}
}

BOOST_AUTO_TEST_CASE(integrationTest_connectTo_zookeeper_basic)
{
	cout << "BOOST_AUTO_TEST_CASE( integrationTest_connectTo_zookeeper_basic )\n{" << endl;

	bool bResult=true;

	static zhandle_t *zh;


	char buffer[512];
	char p[2048];
	char *cert=0;
	char appId[64];

	strcpy(appId, "example.foo_test");
	cert = foo_get_cert_once(appId);
	if(cert!=0) {
		fprintf(stdout,
				"Certificate for appid [%s] is [%s]\n",appId,cert);
		strncpy(p,cert, sizeof(p)-1);
		free(cert);
	} else {
		fprintf(stdout, "Certificate for appid [%s] not found\n",appId);
		strcpy(p, "dummy");
	}

	//zoo_set_debug_level(ZOO_LOG_LEVEL_WARN);
	zoo_set_log_stream(fopen("NULL", "w"));
	zoo_deterministic_conn_order(1); // enable deterministic order
	zh = zookeeper_init("localhost:2181", watcher, 10000, 0, 0, 0);
	if (!zh) {
		cout << "Error number: " << errno << endl;
		bResult=false;
	}
	else {
		cout << "check if watcher assigned new sessionId: " << endl;
		//cout << "state : " << state2String(zoo_state(zh)) << endl;

		bResult = WaitForEvent(2000);
		BOOST_CHECK(zoo_state(zh) == ZOO_CONNECTED_STATE);
		
		zookeeper_close(zh);
	}
	BOOST_CHECK(bResult==true);

	cout << "}" << endl;
}

BOOST_AUTO_TEST_CASE(integrationTest_createZNode_zookeeper_basic)
{
	cout << "BOOST_AUTO_TEST_CASE( integrationTest_createZNode_zookeeper_basic )\n{" << endl;

	bool bResult=true;

	static zhandle_t *zh;


	char buffer[512];
	char p[2048];
	char *cert=0;
	char appId[64];

	strcpy(appId, "example.foo_test");
	cert = foo_get_cert_once(appId);
	if(cert!=0) {
		fprintf(stdout,
				"Certificate for appid [%s] is [%s]\n",appId,cert);
		strncpy(p,cert, sizeof(p)-1);
		free(cert);
	} else {
		fprintf(stdout, "Certificate for appid [%s] not found\n",appId);
		strcpy(p, "dummy");
	}

	//zoo_set_debug_level(ZOO_LOG_LEVEL_WARN);
	zoo_set_log_stream(fopen("NULL", "w"));
	zoo_deterministic_conn_order(1); // enable deterministic order
	zh = zookeeper_init("localhost:2181", watcher, 10000, 0, 0, 0);
	if (!zh) {
		cout << "Error number: " << errno << endl;
		bResult=false;
	}
	else {
		//if(zoo_add_auth(zh,"foo",p,strlen(p),0,0)!=ZOK)
		//	bResult=false;
		//else {
			//struct ACL CREATE_ONLY_ACL[] = {{ZOO_PERM_CREATE, ZOO_AUTH_IDS}};
			struct ACL CREATE_ONLY_ACL[] = {{ZOO_PERM_ALL, ZOO_ANYONE_ID_UNSAFE}};
			struct ACL_vector CREATE_ONLY = {1, CREATE_ONLY_ACL};
			int rc = zoo_create(zh,"/xyz","value", 5, &CREATE_ONLY, ZOO_EPHEMERAL, buffer, sizeof(buffer)-1);
			if (rc) {
				fprintf(stdout, "Error %d, %s for %s [%d] - could NOT create /xyz \n", rc, zerror(rc), __FILE__, __LINE__);
				bResult=false;
			}
			else {
				cout << "Created /xyc znode" << endl;

				int buflen= sizeof(buffer);
				struct Stat stat;
				rc = zoo_get(zh, "/xyz", 0, buffer, &buflen, &stat);
				if (rc) {
					fprintf(stdout, "Error %d, %s  for %s [%d] - could NOT get /xyz \n", rc, zerror(rc), __FILE__, __LINE__);
					bResult=false;
				}
			}
			zookeeper_close(zh);
		//}
	}
	BOOST_CHECK(bResult==true);

	cout << "}" << endl;
}

// ******************************************************************************************************************

BOOST_AUTO_TEST_CASE(integrationTest_connectTo_zookeeper_advanced)
{
	cout << "BOOST_AUTO_TEST_CASE( integrationTest_connectTo_zookeeper_advanced)\n{" << endl;
	
	zoo_set_debug_level(ZOO_LOG_LEVEL_DEBUG);
	//zoo_set_debug_level(ZOO_LOG_LEVEL_WARN);
	//zoo_set_debug_level(ZOO_LOG_LEVEL_INFO);
	//zoo_set_log_stream(fopen("NULL", "w")); // no output
	zoo_set_log_stream(stdout); // redirect from stderr to stdout - meaning output will be within the output scope of this test, not outside as when using stderr

	string servers = "localhost:2181";
	Duration timeout = Seconds(4);
	string znode = "/";
	ZooKeeperStorage* storage = new ZooKeeperStorage(servers, timeout, znode);

	BOOST_CHECK(storage->waitForConnection(1000) == true);

	cout << "}" << endl;
}

BOOST_AUTO_TEST_CASE(integrationTest_listZNodes_zookeeper_advanced)
{
	cout << "BOOST_AUTO_TEST_CASE( integrationTest_listZNodes_zookeeper_advanced)\n{" << endl;
	
	zoo_set_log_stream(fopen("NULL", "w")); // no output
	//zoo_set_log_stream(stdout); // redirect from stderr to stdout 

	string servers = "localhost:2181";
	Duration timeout = Seconds(4);
	string znode = "/";
	ZooKeeperStorage* storage = new ZooKeeperStorage(servers, timeout, znode);
	BOOST_CHECK(storage->waitForConnection(1000) == true);

	// now make a list of ZNodes
	std::string result = storage->ls("/");
	cout << result;
	BOOST_CHECK(result.find("zookeeper") == true); // zookeeper is default znode unless deleted it should be there

	cout << "}" << endl;
}

BOOST_AUTO_TEST_CASE(integrationTest_CreateZNode_zookeeper_advanced)
{
	cout << "BOOST_AUTO_TEST_CASE( integrationTest_CreateZNode_zookeeper_advanced)\n{" << endl;
	BOOST_TEST_MESSAGE( "NB! to start zookeeper for running this test, do following: " );
    BOOST_TEST_MESSAGE( "******************************************" ); 	
	BOOST_TEST_MESSAGE( "/opt/zookeeper-3.4.8/bin/zkServer.sh start" );
    BOOST_TEST_MESSAGE( "******************************************" ); 	
	
	//zoo_set_debug_level(ZOO_LOG_LEVEL_DEBUG);
	zoo_set_log_stream(fopen("NULL", "w")); // no output
	//zoo_set_log_stream(stdout); // redirect from stderr to stdout 

	// First connect to a local running ZooKeeper
	string servers = "localhost:2181";
	Duration timeout = Seconds(4);
	string znode = "/";
	ZooKeeperStorage* storage = new ZooKeeperStorage(servers, timeout, znode);
	BOOST_CHECK(storage->waitForConnection(1000) == true);

	// Second create a znode
	int flags;
	std::string _result = "";
	bool recursive=false;
	std::string data = "my_data";
	int iResult = storage->create("/testNode123", data, &EVERYONE_CREATE_READ, ZOO_EPHEMERAL,&_result,recursive);
	if(iResult>=0) {
		// Third list znodes
		std::string result = storage->ls("/");
		cout << result << endl;
		cout << "OK: zookeeper found at pos: " << result.find("zookeeper") << endl;
		BOOST_CHECK(result.find("zookeeper") > 0); // zookeeper is default znode unless deleted it should be there
		cout << "OK: testNode123 found at pos: " << result.find("testNode123") << endl;
		// Fourth verify that created znode exists
		BOOST_CHECK(result.find("testNode123") > 0); // zookeeper is default znode unless deleted it should be there
	}
	else {
		cout << "FAIL: could NOT create a ZNODE " << endl;
		BOOST_CHECK(true == false);
	}
	cout << "}" << endl;
}

BOOST_AUTO_TEST_CASE(integrationTest_getZNode_zookeeper_advanced)
{
	cout << "BOOST_AUTO_TEST_CASE( integrationTest_getZNode_zookeeper_advanced)\n{" << endl;
	
	//zoo_set_debug_level(ZOO_LOG_LEVEL_DEBUG);
	zoo_set_log_stream(fopen("NULL", "w")); // no output
	//zoo_set_log_stream(stdout); // redirect from stderr to stdout 

	// First connect to a local running ZooKeeper
	string servers = "localhost:2181";
	Duration timeout = Seconds(4);
	string znode = "/";
	ZooKeeperStorage* storage = new ZooKeeperStorage(servers, timeout, znode);
	BOOST_CHECK(storage->waitForConnection(1000) == true);

	// Second create a znode
	int flags;
	std::string _result = "";
	bool recursive=false;
	std::string data = "this is the data in the znode";
	int iResult = storage->create("/testNode", data, &EVERYONE_CREATE_READ, ZOO_EPHEMERAL,&_result,recursive);
	if(iResult>=0) {
		// Third list znodes
		std::string result = storage->ls("/");
		cout << result << endl;
		cout << "OK: zookeeper found at pos: " << result.find("zookeeper") << endl;
		BOOST_CHECK(result.find("zookeeper") > 0); // zookeeper is default znode unless deleted it should be there
		cout << "OK: testNode found at pos: " << result.find("testNode") << endl;
		// Fourth verify that created znode exists
		BOOST_CHECK(result.find("testNode") > 0); // zookeeper is default znode unless deleted it should be there
		// Fifth get the znode
		std::string resultData = "";
		Stat status;
		storage->get("/testNode", false, &resultData, &status);
		BOOST_CHECK(resultData == data);
		if(resultData == data)
			cout << "OK: get from znode : " << resultData << endl;
		else
			cout << "FAIL: get from znode : " << resultData << " is not equal to " << data << endl;
	}
	else {
		cout << "FAIL: could NOT create a ZNODE " << endl;
		BOOST_CHECK(true == false);
	}
	cout << "}" << endl;
}

BOOST_AUTO_TEST_CASE(integrationTest_RPCclient_connectTo_ZooKeeper)
{
	cout << "BOOST_AUTO_TEST_CASE( integrationTest_RPCclient_connectTo_ZooKeeper )\n{" << endl;

	long TIMEOUT_IN_SECONDS = 8;

	// instanciate RPCclient
	RPCclient client;

	// connect to ZooKeeper
	bool bIsConnected = client.connectToZooKeeper("localhost:2181", TIMEOUT_IN_SECONDS, "/");
	BOOST_CHECK(bIsConnected);

	cout << "}" << endl;
}



BOOST_AUTO_TEST_SUITE_END( )

